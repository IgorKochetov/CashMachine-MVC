1. Initial design considerations, decisions and tradeoffs.

1.1 Authorization / Authentication. It was an obvious decision to use mvc authorization mechanism in order to manage access to operations via pin input. Though, it was a debate whether to use just AspNet.Identity.Core and implement everything manually (store, validator, etc), or use ready-made AspNet.Identity.EntityFramework implementation. In order to save time the decision was made to use existing implementation to get results quicker while taking advantage of well tested features, though downside of it was tie coupling to EF components everywhere (from controllers to domain) and a little bit ackward terminology match between Users/Passwords and CreditCardAccounts / Pins.

1.2 EF, DI, IoC. Normally, I am building all my components using Dependency Injection technics, depending on abstractions and asking for consumers to provide implementations either manually in app root or via IoC container of choice (Autofaq, etc) in order to be able to unit test everything and compose components as we need to. Again, to save time (since that is a testing task, not a real production system) I've new-ed up all the components in Controller's constructors, acting like app roots there. Also, abstracting away database layer while using EntityFramework usually takes implementing Repository pattern (and Unit of Work pattern also), so all the services of the application talk to repositories instead of DbContexts. Again, for simplicity's sake those were omited here. However, in OperationsController I've tried to showcase that approach a little bit, by abstracting away DbContext from Controller into Service (IAccountOperationService). Again, if we would use proper DI/IoC technics here, controller would be talking exclusively to an interface not knowing about DbContext at all. See tests (OperationsControllerTests) for example.

1.3 Solution / project structure. For the real production system we would keep domain / contracts in a separate dll and database (EF stuff) in a separate dll, in order to keep our Web project conserned only about MVC infrastructure, while also allow us to independently test our domain in unit tests or database (EF, DbContexts, etc) in integration tests.

2. Database. Since the choice was made to use out-of-the box Identity library for storing our Accounts, we were already given an initial database. Again, in order to save time we keep initial tables / scripts in tact to be able to quickly change things using EF Migrations and PackageManagerConsole. We extended Users/Accounts table to also store Balance and login security information and added operations table for logging user activity. No Foreign Keys were added between the two since Operations could easily be in another Database in some of the future releases and we are not planning to really query / join those tables, let alone updating them. So no real worries about integrity at this stage.

3. Unit testing. For simplicity we are not doing any integration tests here and unit-testing only handful of components. Real system would be having a much stronger test suite taking advantage of more decoupled desing throught the solution.

4. Logging, Exception handling. Obviously, our app lacks logging and proper exception handling. While 1st one is relatively easy to achive by adding any of the production level loggin libraries (NLog, Log4net, etc), 2nd requires more insight and team strategy on handling exceptions, re-trying policies, properly managing state of the app, providing some sort of feedback to user, etc. For now it is enough to just rely on standart MVC HandleError attribure / filter and shared Error page.

5. Requirements (Operations, Results, Reports). According to current requirements we are not using Logged Operations anywere, though we could be generating our WithdrawalReport and Balance views passing an Id of logged operation and using OperationLog entity to display results to the user, saving us some hardly needed types in OperationResult and AccountBalanceStamp. But again, in order to fine-tune our design we should be able to have at least some sort of feedback from our 'customer' and see some future requirements / adjusments.